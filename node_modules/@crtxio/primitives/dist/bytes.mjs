import { isIterable } from '@crtxio/utils';
import { log2Byte } from '@crtxio/utils/calc';
import { Bases } from '@crtxio/bases';
import * as base32 from '@crtxio/bases/base32';
import * as base58 from '@crtxio/bases/base58';
import * as base64 from '@crtxio/bases/base64';

const CommonBases = new Bases({
  ...base32,
  ...base58,
  ...base64
});

class Bytes extends Uint8Array {
  constructor(bytes = [], clamp = 0) {
    var __super = (...args) => {
      super(...args);
    };
    if (typeof bytes == "string") {
      bytes = CommonBases.decode(bytes, "hex");
    }
    if (isIterable(bytes)) {
      bytes = [...Array(clamp).fill(0), ...bytes].slice(clamp * -1);
      __super(bytes);
    } else {
      throw Error("not byte like");
    }
    this._n = BigInt(CommonBases.encode(this));
    this._bits = bytes.length * 8;
    this._maxIndex = this._bits - 1;
  }
  bytesLikeThis(bytes) {
    return new this.constructor(bytes);
  }
  get n() {
    return this._n;
  }
  get bytes() {
    return Uint8Array.from(this);
  }
  get copy() {
    return this.bytesLikeThis(this);
  }
  get isZero() {
    return !this.ones;
  }
  get isNull() {
    return this.isZero;
  }
  get isEmpty() {
    return this.isZero;
  }
  toString(encoding = "hex", prefix = true) {
    return CommonBases.encode(this, encoding, prefix);
  }
  toBin(compact = false, bit = -1) {
    let bin = this.reduce((str, byte) => str + byte.toString(2).padStart(8, "0"), "");
    if (bit >= 0 && bit <= 255) {
      bin = `${bin.substring(0, bit)}\x1B[31m${bin.substring(bit)}\x1B[0m`;
    }
    if (compact) {
      bin = bin.replace(/^(00000000)+/, "");
    }
    return "0b" + bin;
  }
  on(index, le = false) {
    if (le) {
      index = this._maxIndex - index;
    }
    this._checkIndex(index);
    this[index >> 3] |= 128 >> (index & 7);
    return this;
  }
  off(index, le = false) {
    if (le) {
      index = this._maxIndex - index;
    }
    this._checkIndex(index);
    this[index >> 3] &= ~(128 >> (index & 7));
    return this;
  }
  flip(index, le = false) {
    if (le) {
      index = this._maxIndex - index;
    }
    this._checkIndex(index);
    this[index >> 3] ^= 128 >> (index & 7);
    return this;
  }
  bit(index, le = false) {
    if (le) {
      index = this._maxIndex - index;
    }
    this._checkIndex(index);
    return this[index >> 3] >> 7 - index % 8 & 1;
  }
  get lsb() {
    let byte, i = 31;
    while (!(byte = this[i]) && i--) {
    }
    return i * 8 + 7 - (log2Byte(byte ^ (byte &= byte - 1)) ?? 0);
  }
  get msb() {
    let byte, i = 0;
    while (!(byte = this[i]) && i < 31) {
      i++;
    }
    return i * 8 + 7 - (log2Byte(byte) ?? 256);
  }
  get ones() {
    return this.reduce((ones, byte) => {
      while (byte) {
        byte &= byte - 1;
        ones++;
      }
      return ones;
    }, 0);
  }
  get zeros() {
    return this._bits - this.ones;
  }
  get not() {
    return this.bytesLikeThis([...this].map((byte) => {
      return ~byte & 255;
    }));
  }
  iand(b) {
    return b.reduce((bytes, byte, i) => {
      bytes[i] &= byte;
      return bytes;
    }, this);
  }
  and(b) {
    return this.copy.iand(b);
  }
  ior(b) {
    return b.reduce((bytes, byte, i) => {
      bytes[i] |= byte;
      return bytes;
    }, this);
  }
  or(b) {
    return this.copy.ior(b);
  }
  ixor(b) {
    return b.reduce((bytes, byte, i) => {
      bytes[i] ^= byte;
      return bytes;
    }, this);
  }
  xor(b) {
    return this.copy.ixor(b);
  }
  compare(b) {
    return this.xor(b).msb;
  }
  equals(b) {
    return this.compare(b) === -1;
  }
  slice(start, end) {
    return this.bytesLikeThis(this.bytes.slice(start, end));
  }
  _checkIndex(index) {
    if (index > this._maxIndex || index < 0) {
      throw Error(`index (${index}) out of bounds ${this._maxIndex}`);
    }
  }
  static from(bytes) {
    return new this(bytes);
  }
  static ensure(bytes, encoding) {
    if (bytes instanceof Bytes)
      return bytes;
    if (typeof bytes == "string")
      bytes = CommonBases.ensure(bytes, encoding);
    return new this(bytes);
  }
  static get zero() {
    return new Bytes();
  }
  static get null() {
    return this.zero;
  }
  static get empty() {
    return this.zero;
  }
}

export { Bytes };
