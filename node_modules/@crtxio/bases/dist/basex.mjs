import { MultibaseCodec } from './abstract.mjs';

class BaseX extends MultibaseCodec {
  constructor(name, prefix, alphabet) {
    super(name, prefix);
    this._basemap = new Uint8Array(256);
    this._validator = new RegExp(`^${prefix}[${alphabet}]+$`);
    this._alphabet = alphabet;
    this._base = alphabet.length;
    this._leader = alphabet.charAt(0);
    this._factor = Math.log(this._base) / Math.log(256);
    this._ifactor = Math.log(256) / Math.log(this._base);
    if (this._base >= 255)
      throw new TypeError("Alphabet too long");
    for (let j = 0; j < this._basemap.length; j++) {
      this._basemap[j] = 255;
    }
    for (let i = 0; i < alphabet.length; i++) {
      const x = alphabet.charAt(i);
      const xc = x.charCodeAt(0);
      if (this._basemap[xc] !== 255)
        throw new TypeError(x + " is ambiguous");
      this._basemap[xc] = i;
    }
  }
  get alphabet() {
    return this._alphabet;
  }
  isValid(str) {
    return this._validator.test(str);
  }
  encode(bytes, prefix = true) {
    if (bytes.length === 0)
      return prefix ? this.prefix : "";
    let zeroes = 0;
    let length = 0;
    let pbegin = 0;
    const pend = bytes.length;
    while (pbegin !== pend && bytes[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    const size = (pend - pbegin) * this._ifactor + 1 >>> 0;
    const b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      let carry = bytes[pbegin];
      let i = 0;
      for (let it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % this._base >>> 0;
        carry = carry / this._base >>> 0;
      }
      if (carry !== 0)
        throw new Error("Non-zero carry");
      length = i;
      pbegin++;
    }
    let it2 = size - length;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    let str = this._leader.repeat(zeroes);
    for (; it2 < size; ++it2)
      str += this.alphabet.charAt(b58[it2]);
    return prefix ? this.prefix + str : str;
  }
  decode(str, prefix = true) {
    if (prefix) {
      if (str[0] != this.prefix)
        throw Error("invalid prefix");
      str = str.slice(1);
    }
    if (str.length === 0)
      return new Uint8Array();
    let psz = 0;
    let zeroes = 0;
    let length = 0;
    while (str[psz] === this._leader) {
      zeroes++;
      psz++;
    }
    const size = (str.length - psz) * this._factor + 1 >>> 0;
    const b256 = new Uint8Array(size);
    while (str[psz]) {
      let carry = this._basemap[str.charCodeAt(psz)];
      if (carry === 255)
        throw Error("invalid character");
      let i = 0;
      for (let it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
        carry += this._base * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0)
        throw new Error("Non-zero carry");
      length = i;
      psz++;
    }
    let it4 = size - length;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    const vch = new Uint8Array(zeroes + (size - it4));
    let j = zeroes;
    while (it4 !== size) {
      vch[j++] = b256[it4++];
    }
    return vch;
  }
  static from({ name, prefix, alphabet }) {
    return new BaseX(name, prefix, alphabet);
  }
}

export { BaseX };
