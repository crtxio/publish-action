export declare const CURVE: {
    P: bigint;
    r: bigint;
    h: bigint;
    Gx: bigint;
    Gy: bigint;
    b: bigint;
    P2: bigint;
    h2: bigint;
    G2x: bigint[];
    G2y: bigint[];
    b2: bigint[];
    x: bigint;
    h2Eff: bigint;
};
declare type BigintTuple = [bigint, bigint];
declare type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];
declare type BigintTwelve = [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
];
interface Field<T> {
    isZero(): boolean;
    equals(rhs: T): boolean;
    negate(): T;
    add(rhs: T): T;
    subtract(rhs: T): T;
    invert(): T;
    multiply(rhs: T | bigint): T;
    square(): T;
    pow(n: bigint): T;
    div(rhs: T | bigint): T;
}
declare type FieldStatic<T extends Field<T>> = {
    ZERO: T;
    ONE: T;
};
export declare function mod(a: bigint, b: bigint): bigint;
export declare function powMod(num: bigint, power: bigint, modulo: bigint): bigint;
export declare function hexToBytes(hex: string): Uint8Array;
export declare function numberToBytesBE(num: bigint, byteLength: number): Uint8Array;
export declare function bytesToHex(uint8a: Uint8Array): string;
export declare function bytesToNumberBE(bytes: Uint8Array): bigint;
export declare function concatBytes(...arrays: Uint8Array[]): Uint8Array;
export declare class Fp implements Field<Fp> {
    static readonly ORDER: bigint;
    static readonly MAX_BITS: number;
    static readonly BYTES_LEN: number;
    static readonly ZERO: Fp;
    static readonly ONE: Fp;
    readonly value: bigint;
    constructor(value: bigint);
    isZero(): boolean;
    equals(rhs: Fp): boolean;
    negate(): Fp;
    invert(): Fp;
    add(rhs: Fp): Fp;
    square(): Fp;
    pow(n: bigint): Fp;
    sqrt(): Fp | undefined;
    subtract(rhs: Fp): Fp;
    multiply(rhs: Fp | bigint): Fp;
    div(rhs: Fp | bigint): Fp;
    toString(): string;
    static fromBytes(b: Uint8Array): Fp;
    toBytes(): Uint8Array;
}
export declare class Fr implements Field<Fr> {
    static readonly ORDER: bigint;
    static readonly ZERO: Fr;
    static readonly ONE: Fr;
    readonly value: bigint;
    constructor(value: bigint);
    static isValid(b: bigint): boolean;
    isZero(): boolean;
    equals(rhs: Fr): boolean;
    negate(): Fr;
    invert(): Fr;
    add(rhs: Fr): Fr;
    square(): Fr;
    pow(n: bigint): Fr;
    subtract(rhs: Fr): Fr;
    multiply(rhs: Fr | bigint): Fr;
    div(rhs: Fr | bigint): Fr;
    legendre(): Fr;
    sqrt(): Fr | undefined;
    toString(): string;
}
export declare class Fp2 implements Field<Fp2> {
    readonly c0: Fp;
    readonly c1: Fp;
    static readonly ORDER: bigint;
    static readonly MAX_BITS: number;
    static readonly BYTES_LEN: number;
    static readonly ZERO: Fp2;
    static readonly ONE: Fp2;
    constructor(c0: Fp, c1: Fp);
    static fromBigTuple(tuple: BigintTuple | bigint[]): Fp2;
    one(): Fp2;
    isZero(): boolean;
    toString(): string;
    reim(): {
        re: bigint;
        im: bigint;
    };
    negate(): Fp2;
    equals(rhs: Fp2): boolean;
    add(rhs: Fp2): Fp2;
    subtract(rhs: Fp2): Fp2;
    multiply(rhs: Fp2 | bigint): Fp2;
    pow(n: bigint): Fp2;
    div(rhs: Fp2 | bigint): Fp2;
    mulByNonresidue(): Fp2;
    square(): Fp2;
    sqrt(): Fp2 | undefined;
    invert(): Fp2;
    frobeniusMap(power: number): Fp2;
    multiplyByB(): Fp2;
    static fromBytes(b: Uint8Array): Fp2;
    toBytes(): Uint8Array;
}
export declare class Fp6 implements Field<Fp6> {
    readonly c0: Fp2;
    readonly c1: Fp2;
    readonly c2: Fp2;
    static readonly ZERO: Fp6;
    static readonly ONE: Fp6;
    static readonly BYTES_LEN: number;
    static fromBigSix(t: BigintSix): Fp6;
    constructor(c0: Fp2, c1: Fp2, c2: Fp2);
    fromTriple(triple: [Fp2, Fp2, Fp2]): Fp6;
    one(): Fp6;
    isZero(): boolean;
    negate(): Fp6;
    toString(): string;
    equals(rhs: Fp6): boolean;
    add(rhs: Fp6): Fp6;
    subtract(rhs: Fp6): Fp6;
    multiply(rhs: Fp6 | bigint): Fp6;
    pow(n: bigint): Fp6;
    div(rhs: Fp6 | bigint): Fp6;
    mulByNonresidue(): Fp6;
    multiplyBy1(b1: Fp2): Fp6;
    multiplyBy01(b0: Fp2, b1: Fp2): Fp6;
    multiplyByFp2(rhs: Fp2): Fp6;
    square(): Fp6;
    invert(): Fp6;
    frobeniusMap(power: number): Fp6;
    static fromBytes(b: Uint8Array): Fp6;
    toBytes(): Uint8Array;
}
export declare class Fp12 implements Field<Fp12> {
    readonly c0: Fp6;
    readonly c1: Fp6;
    static readonly ZERO: Fp12;
    static readonly ONE: Fp12;
    static readonly BYTES_LEN: number;
    static fromBigTwelve(t: BigintTwelve): Fp12;
    constructor(c0: Fp6, c1: Fp6);
    fromTuple(c: [Fp6, Fp6]): Fp12;
    one(): Fp12;
    isZero(): boolean;
    toString(): string;
    negate(): Fp12;
    equals(rhs: Fp12): boolean;
    add(rhs: Fp12): Fp12;
    subtract(rhs: Fp12): Fp12;
    multiply(rhs: Fp12 | bigint): Fp12;
    pow(n: bigint): Fp12;
    div(rhs: Fp12 | bigint): Fp12;
    multiplyBy014(o0: Fp2, o1: Fp2, o4: Fp2): Fp12;
    multiplyByFp2(rhs: Fp2): Fp12;
    square(): Fp12;
    invert(): Fp12;
    conjugate(): Fp12;
    frobeniusMap(power: number): Fp12;
    private Fp4Square;
    private cyclotomicSquare;
    private cyclotomicExp;
    finalExponentiate(): Fp12;
    static fromBytes(b: Uint8Array): Fp12;
    toBytes(): Uint8Array;
}
declare type Constructor<T extends Field<T>> = {
    new (...args: any[]): T;
} & FieldStatic<T> & {
    MAX_BITS: number;
};
export declare abstract class ProjectivePoint<T extends Field<T>> {
    readonly x: T;
    readonly y: T;
    readonly z: T;
    private readonly C;
    private _MPRECOMPUTES;
    constructor(x: T, y: T, z: T, C: Constructor<T>);
    isZero(): boolean;
    createPoint<TT extends this>(x: T, y: T, z: T): TT;
    getZero(): this;
    equals(rhs: ProjectivePoint<T>): boolean;
    negate(): this;
    toString(isAffine?: boolean): string;
    fromAffineTuple(xy: [T, T]): this;
    toAffine(invZ?: T): [T, T];
    toAffineBatch(points: ProjectivePoint<T>[]): [T, T][];
    normalizeZ(points: this[]): this[];
    double(): this;
    add(rhs: this): this;
    subtract(rhs: this): this;
    private validateScalar;
    multiplyUnsafe(scalar: bigint): this;
    multiply(scalar: bigint): this;
    private maxBits;
    private precomputeWindow;
    calcMultiplyPrecomputes(W: number): void;
    clearMultiplyPrecomputes(): void;
    private wNAF;
    multiplyPrecomputed(scalar: bigint): this;
}
export declare function map_to_curve_simple_swu_9mod16(t: bigint[] | Fp2): [Fp2, Fp2];
export declare function map_to_curve_simple_swu_3mod4(u: Fp): [Fp, Fp];
export declare const isogenyMapG2: (x: Fp2, y: Fp2) => [Fp2, Fp2];
export declare const isogenyMapG1: (x: Fp, y: Fp) => [Fp, Fp];
export declare function calcPairingPrecomputes(x: Fp2, y: Fp2): [Fp2, Fp2, Fp2][];
export declare function millerLoop(ell: [Fp2, Fp2, Fp2][], g1: [Fp, Fp]): Fp12;
export declare function psi(x: Fp2, y: Fp2): [Fp2, Fp2];
export declare function psi2(x: Fp2, y: Fp2): [Fp2, Fp2];
export {};
