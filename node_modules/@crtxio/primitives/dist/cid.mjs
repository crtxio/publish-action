import { varint } from '@crtxio/utils/varint';
import { Bytes } from './bytes.mjs';
import { validateTypedData, getMessage } from 'eip-712';
import { Hashers } from '@crtxio/hashers';
import * as sha3 from '@crtxio/hashers/sha3';
import '@crtxio/utils';
import '@crtxio/utils/calc';
import '@crtxio/bases';
import '@crtxio/bases/base32';
import '@crtxio/bases/base58';
import '@crtxio/bases/base64';

const CommonHashers = new Hashers({ ...sha3 });
class Hash extends Bytes {
  constructor(bytes, code) {
    super(bytes);
    this.code = code;
  }
  get raw() {
    return Bytes.from([
      ...varint.encode(this.code),
      ...varint.encode(this.length),
      ...this
    ]);
  }
  to(encoding = "hex", prefix = true) {
    return this.raw.toString(encoding, prefix);
  }
  static is(hash) {
    try {
      hash = this.from(hash);
      return hash instanceof Hash;
    } catch {
      return false;
    }
  }
  static from(hash) {
    if (hash instanceof Hash)
      return hash;
    const bytes = Bytes.from(hash);
    const code = varint.take(bytes);
    const len = varint.take(bytes, code[1]);
    const digest = bytes.slice(len[1]);
    return new Hash(digest, code[0]);
  }
  static async create(data, hasher = "identity") {
    if (validateTypedData(data))
      return new Hash(getMessage(data, true), 27);
    const bytes = Bytes.ensure(data);
    const { digest, code } = await CommonHashers.encode(bytes, hasher);
    return new Hash(digest, code);
  }
}

const Codecs = {
  identity: 0,
  "bls12_381-g1-pub": 234,
  "bls12_381-g2-pub": 235,
  "secp256k1-pub": 231,
  "keccak-256": 27,
  "sha2-256": 18,
  "eth-block": 144,
  "dag-cbor": 113,
  "dag-pb": 112,
  cbor: 81
};
const CodecNames = [];
for (const codec of Object.keys(Codecs)) {
  CodecNames[Codecs[codec]] = codec;
}
const isV0 = RegExp("^Qm[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{44}$");
class CID extends Bytes {
  constructor(hash, code, version = 1) {
    const bytes = version ? Bytes.from([version, ...varint.encode(code), ...hash.raw]) : hash.raw;
    super(bytes);
    this.hash = hash;
    this.code = code;
    this.version = version;
  }
  get raw() {
    return Bytes.from(this);
  }
  get v0() {
    return this.version ? new CID(this.hash, this.code, 0) : this;
  }
  get v1() {
    return this.version ? this : new CID(this.hash, this.code, 1);
  }
  get alg() {
    return CodecNames[this.hash.code] || "0x" + this.hash.code.toString(16);
  }
  get codec() {
    return CodecNames[this.code];
  }
  get humanize() {
    const version = this.version ? "cidv1" : "cidv0";
    return [
      version,
      this.codec,
      this.alg,
      this.hash.length,
      this.hash.to("hex", false)
    ].join(" - ");
  }
  to(encoding = "base32") {
    if (this.version == 0)
      return this.hash.to("base58btc", false);
    return super.toString(encoding, true);
  }
  static is(cid) {
    try {
      cid = this.from(cid);
      return cid instanceof CID;
    } catch {
      return false;
    }
  }
  static isV0(cid) {
    if (typeof cid == "string")
      return isV0.test(cid);
    const bytes = Bytes.ensure(cid);
    return bytes.length == 34 && bytes[0] == 18 && bytes[1] == 32;
  }
  static isV1(cid) {
    const bytes = Bytes.ensure(cid);
    return bytes[0] == 1;
  }
  static from(cid) {
    if (cid instanceof CID)
      return cid;
    if (CID.isV0(cid)) {
      return new CID(Hash.from(Bytes.ensure(cid, "base58btc")), 112, 0);
    }
    const bytes = Bytes.ensure(cid);
    if (!CID.isV1(cid))
      throw Error("invalid CID");
    const [codec, offset] = varint.take(bytes, 1);
    const hash = Hash.from(bytes.slice(offset));
    return new CID(hash, codec, 1);
  }
  static create(hash, codec, version = 1) {
    if (typeof codec == "string")
      codec = Codecs[codec];
    return new CID(Hash.from(hash), codec, version);
  }
}

export { CID };
