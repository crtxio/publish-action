/*! noble-bls12-381 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
import { hexToBytes, bytesToHex, Fp, Fr, Fp2, Fp12, CURVE, ProjectivePoint, mod } from './math.js';
export { Fp, Fr, Fp2, Fp12, CURVE };
declare type Hex = Uint8Array | string;
declare type PrivateKey = Hex | bigint | number;
declare type BasicHash = (msg: Uint8Array) => Uint8Array | Promise<Uint8Array>;
declare type Hash = BasicHash & {
    outputLen: number;
};
declare const htfDefaults: {
    DST: string;
    p: bigint;
    m: number;
    k: number;
    expand: boolean;
    hash: Hash;
};
export declare const utils: {
    hashToField: typeof hash_to_field;
    expandMessageXMD: typeof expand_message_xmd;
    hashToPrivateKey: (hash: Hex) => Uint8Array;
    stringToBytes: typeof stringToBytes;
    bytesToHex: typeof bytesToHex;
    hexToBytes: typeof hexToBytes;
    randomBytes: (bytesLength?: number) => Uint8Array;
    randomPrivateKey: () => Uint8Array;
    sha256: Hash;
    mod: typeof mod;
    getDSTLabel(): string;
    setDSTLabel(newLabel: string): void;
};
declare function stringToBytes(str: string): Uint8Array;
declare function expand_message_xmd(msg: Uint8Array, DST: Uint8Array, lenInBytes: number, H?: Hash): Promise<Uint8Array>;
declare function hash_to_field(msg: Uint8Array, count: number, options?: Partial<typeof htfDefaults>): Promise<bigint[][]>;
export declare class PointG1 extends ProjectivePoint<Fp> {
    static BASE: PointG1;
    static ZERO: PointG1;
    constructor(x: Fp, y: Fp, z?: Fp);
    static fromHex(bytes: Hex): PointG1;
    static hashToCurve(msg: Hex, options?: Partial<typeof htfDefaults>): Promise<PointG1>;
    static encodeToCurve(msg: Hex, options?: Partial<typeof htfDefaults>): Promise<PointG1>;
    static fromPrivateKey(privateKey: PrivateKey): PointG1;
    toRawBytes(isCompressed?: boolean): Uint8Array;
    toHex(isCompressed?: boolean): string;
    assertValidity(): this;
    millerLoop(P: PointG2): Fp12;
    clearCofactor(): PointG1;
    private isOnCurve;
    private sigma;
    private phi;
    private mulCurveX;
    private mulCurveMinusX;
    private isTorsionFree;
}
export declare class PointG2 extends ProjectivePoint<Fp2> {
    static BASE: PointG2;
    static ZERO: PointG2;
    private _PPRECOMPUTES;
    constructor(x: Fp2, y: Fp2, z?: Fp2);
    static hashToCurve(msg: Hex, options?: Partial<typeof htfDefaults>): Promise<PointG2>;
    static encodeToCurve(msg: Hex, options?: Partial<typeof htfDefaults>): Promise<PointG2>;
    static fromSignature(hex: Hex): PointG2;
    static fromHex(bytes: Hex): PointG2;
    static fromPrivateKey(privateKey: PrivateKey): PointG2;
    toSignature(): Uint8Array;
    toRawBytes(isCompressed?: boolean): Uint8Array;
    toHex(isCompressed?: boolean): string;
    assertValidity(): this;
    private psi;
    private psi2;
    private mulCurveX;
    clearCofactor(): PointG2;
    private isOnCurve;
    private isTorsionFree;
    clearPairingPrecomputes(): void;
    pairingPrecomputes(): [Fp2, Fp2, Fp2][];
}
export declare function pairing(P: PointG1, Q: PointG2, withFinalExponent?: boolean): Fp12;
declare type G1Hex = Hex | PointG1;
declare type G2Hex = Hex | PointG2;
export declare function getPublicKey(privateKey: PrivateKey): Uint8Array;
export declare function sign(message: Hex, privateKey: PrivateKey): Promise<Uint8Array>;
export declare function sign(message: PointG2, privateKey: PrivateKey): Promise<PointG2>;
export declare function verify(signature: G2Hex, message: G2Hex, publicKey: G1Hex): Promise<boolean>;
export declare function aggregatePublicKeys(publicKeys: Hex[]): Uint8Array;
export declare function aggregatePublicKeys(publicKeys: PointG1[]): PointG1;
export declare function aggregateSignatures(signatures: Hex[]): Uint8Array;
export declare function aggregateSignatures(signatures: PointG2[]): PointG2;
export declare function verifyBatch(signature: G2Hex, messages: G2Hex[], publicKeys: G1Hex[]): Promise<boolean>;
