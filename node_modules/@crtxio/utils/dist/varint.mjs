const MSB = 128, REST = 127, MSBALL = ~REST, N1 = Math.pow(2, 7), N2 = Math.pow(2, 14), N3 = Math.pow(2, 21), N4 = Math.pow(2, 28), N5 = Math.pow(2, 35), N6 = Math.pow(2, 42), N7 = Math.pow(2, 49), N8 = Math.pow(2, 56), N9 = Math.pow(2, 63), INT = Math.pow(2, 31);
function encode(num) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    throw new RangeError("Could not encode varint");
  }
  const out = [];
  let offset = 0;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  return Uint8Array.from(out);
}
function decode(bytes, offset = 0) {
  const l = bytes.length;
  let res = 0, shift = 0, b;
  do {
    if (offset >= l || shift > 49) {
      throw new RangeError("Could not decode varint");
    }
    b = bytes[offset++];
    res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB);
  return res;
}
function length(value) {
  const NS = [N1, N2, N3, N4, N5, N6, N7, N8, N9];
  const i = NS.findIndex((n) => value < n);
  return i + 1;
}
function take(bytes, offset = 0) {
  const num = decode(bytes, offset);
  return [num, offset + length(num)];
}
const varint = { take, encode, decode, length };

export { decode, encode, length, take, varint };
