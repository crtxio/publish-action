"use strict";
/*! noble-bls12-381 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyBatch = exports.aggregateSignatures = exports.aggregatePublicKeys = exports.verify = exports.sign = exports.getPublicKey = exports.pairing = exports.PointG2 = exports.PointG1 = exports.utils = exports.CURVE = exports.Fp12 = exports.Fp2 = exports.Fr = exports.Fp = void 0;
const crypto_1 = __importDefault(require("crypto"));
const math_js_1 = require("./math.js");
Object.defineProperty(exports, "Fp", { enumerable: true, get: function () { return math_js_1.Fp; } });
Object.defineProperty(exports, "Fr", { enumerable: true, get: function () { return math_js_1.Fr; } });
Object.defineProperty(exports, "Fp2", { enumerable: true, get: function () { return math_js_1.Fp2; } });
Object.defineProperty(exports, "Fp12", { enumerable: true, get: function () { return math_js_1.Fp12; } });
Object.defineProperty(exports, "CURVE", { enumerable: true, get: function () { return math_js_1.CURVE; } });
const POW_2_381 = 2n ** 381n;
const POW_2_382 = POW_2_381 * 2n;
const POW_2_383 = POW_2_382 * 2n;
const PUBLIC_KEY_LENGTH = 48;
function wrapHash(outputLen, h) {
    let tmp = h;
    tmp.outputLen = outputLen;
    return tmp;
}
const sha256 = wrapHash(32, async (message) => {
    if (crypto.web) {
        const buffer = await crypto.web.subtle.digest('SHA-256', message.buffer);
        return new Uint8Array(buffer);
    }
    else if (crypto.node) {
        return Uint8Array.from(crypto.node.createHash('sha256').update(message).digest());
    }
    else {
        throw new Error("The environment doesn't have sha256 function");
    }
});
const htfDefaults = {
    DST: 'BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_',
    p: math_js_1.CURVE.P,
    m: 2,
    k: 128,
    expand: true,
    hash: sha256,
};
function isWithinCurveOrder(num) {
    return 0 < num && num < math_js_1.CURVE.r;
}
const crypto = {
    node: crypto_1.default,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
exports.utils = {
    hashToField: hash_to_field,
    expandMessageXMD: expand_message_xmd,
    hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        const num = (0, math_js_1.mod)((0, math_js_1.bytesToNumberBE)(hash), math_js_1.CURVE.r);
        if (num === 0n || num === 1n)
            throw new Error('Invalid private key');
        return numberTo32BytesBE(num);
    },
    stringToBytes,
    bytesToHex: math_js_1.bytesToHex,
    hexToBytes: math_js_1.hexToBytes,
    randomBytes: (bytesLength = 32) => {
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => {
        return exports.utils.hashToPrivateKey(exports.utils.randomBytes(40));
    },
    sha256,
    mod: math_js_1.mod,
    getDSTLabel() {
        return htfDefaults.DST;
    },
    setDSTLabel(newLabel) {
        if (typeof newLabel !== 'string' || newLabel.length > 2048 || newLabel.length === 0) {
            throw new TypeError('Invalid DST');
        }
        htfDefaults.DST = newLabel;
    },
};
function numberTo32BytesBE(num) {
    const length = 32;
    const hex = num.toString(16).padStart(length * 2, '0');
    return (0, math_js_1.hexToBytes)(hex);
}
function toPaddedHex(num, padding) {
    if (typeof num !== 'bigint' || num < 0n)
        throw new Error('Expected valid bigint');
    if (typeof padding !== 'number')
        throw new TypeError('Expected valid padding');
    return num.toString(16).padStart(padding * 2, '0');
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : (0, math_js_1.hexToBytes)(hex);
}
function stringToBytes(str) {
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
function os2ip(bytes) {
    let result = 0n;
    for (let i = 0; i < bytes.length; i++) {
        result <<= 8n;
        result += BigInt(bytes[i]);
    }
    return result;
}
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
async function expand_message_xmd(msg, DST, lenInBytes, H = exports.utils.sha256) {
    if (DST.length > 255)
        DST = await H((0, math_js_1.concatBytes)(stringToBytes('H2C-OVERSIZE-DST-'), DST));
    const b_in_bytes = H.outputLen;
    const r_in_bytes = b_in_bytes * 2;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, math_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2);
    const b = new Array(ell);
    const b_0 = await H((0, math_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = await H((0, math_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = await H((0, math_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, math_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
async function hash_to_field(msg, count, options = {}) {
    const htfOptions = { ...htfDefaults, ...options };
    const log2p = htfOptions.p.toString(2).length;
    const L = Math.ceil((log2p + htfOptions.k) / 8);
    const len_in_bytes = count * htfOptions.m * L;
    const DST = stringToBytes(htfOptions.DST);
    let pseudo_random_bytes = msg;
    if (htfOptions.expand) {
        pseudo_random_bytes = await expand_message_xmd(msg, DST, len_in_bytes, htfOptions.hash);
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(htfOptions.m);
        for (let j = 0; j < htfOptions.m; j++) {
            const elm_offset = L * (j + i * htfOptions.m);
            const tv = pseudo_random_bytes.subarray(elm_offset, elm_offset + L);
            e[j] = (0, math_js_1.mod)(os2ip(tv), htfOptions.p);
        }
        u[i] = e;
    }
    return u;
}
function normalizePrivKey(key) {
    let int;
    if (key instanceof Uint8Array && key.length === 32)
        int = (0, math_js_1.bytesToNumberBE)(key);
    else if (typeof key === 'string' && key.length === 64)
        int = BigInt(`0x${key}`);
    else if (typeof key === 'number' && key > 0 && Number.isSafeInteger(key))
        int = BigInt(key);
    else if (typeof key === 'bigint' && key > 0n)
        int = key;
    else
        throw new TypeError('Expected valid private key');
    int = (0, math_js_1.mod)(int, math_js_1.CURVE.r);
    if (!isWithinCurveOrder(int))
        throw new Error('Private key must be 0 < key < CURVE.r');
    return int;
}
function assertType(item, type) {
    if (!(item instanceof type))
        throw new Error('Expected Fp* argument, not number/bigint');
}
class PointG1 extends math_js_1.ProjectivePoint {
    constructor(x, y, z = math_js_1.Fp.ONE) {
        super(x, y, z, math_js_1.Fp);
        assertType(x, math_js_1.Fp);
        assertType(y, math_js_1.Fp);
        assertType(z, math_js_1.Fp);
    }
    static fromHex(bytes) {
        bytes = ensureBytes(bytes);
        let point;
        if (bytes.length === 48) {
            const { P } = math_js_1.CURVE;
            const compressedValue = (0, math_js_1.bytesToNumberBE)(bytes);
            const bflag = (0, math_js_1.mod)(compressedValue, POW_2_383) / POW_2_382;
            if (bflag === 1n) {
                return this.ZERO;
            }
            const x = new math_js_1.Fp((0, math_js_1.mod)(compressedValue, POW_2_381));
            const right = x.pow(3n).add(new math_js_1.Fp(math_js_1.CURVE.b));
            let y = right.sqrt();
            if (!y)
                throw new Error('Invalid compressed G1 point');
            const aflag = (0, math_js_1.mod)(compressedValue, POW_2_382) / POW_2_381;
            if ((y.value * 2n) / P !== aflag)
                y = y.negate();
            point = new PointG1(x, y);
        }
        else if (bytes.length === 96) {
            if ((bytes[0] & (1 << 6)) !== 0)
                return PointG1.ZERO;
            const x = (0, math_js_1.bytesToNumberBE)(bytes.slice(0, PUBLIC_KEY_LENGTH));
            const y = (0, math_js_1.bytesToNumberBE)(bytes.slice(PUBLIC_KEY_LENGTH));
            point = new PointG1(new math_js_1.Fp(x), new math_js_1.Fp(y));
        }
        else {
            throw new Error('Invalid point G1, expected 48/96 bytes');
        }
        point.assertValidity();
        return point;
    }
    static async hashToCurve(msg, options) {
        msg = ensureBytes(msg);
        const [[u0], [u1]] = await hash_to_field(msg, 2, { m: 1, ...options });
        const [x0, y0] = (0, math_js_1.map_to_curve_simple_swu_3mod4)(new math_js_1.Fp(u0));
        const [x1, y1] = (0, math_js_1.map_to_curve_simple_swu_3mod4)(new math_js_1.Fp(u1));
        const [x2, y2] = new PointG1(x0, y0).add(new PointG1(x1, y1)).toAffine();
        const [x3, y3] = (0, math_js_1.isogenyMapG1)(x2, y2);
        return new PointG1(x3, y3).clearCofactor();
    }
    static async encodeToCurve(msg, options) {
        msg = ensureBytes(msg);
        const u = await hash_to_field(msg, 1, {
            m: 1,
            ...options,
        });
        const [x0, y0] = (0, math_js_1.map_to_curve_simple_swu_3mod4)(new math_js_1.Fp(u[0][0]));
        const [x1, y1] = (0, math_js_1.isogenyMapG1)(x0, y0);
        return new PointG1(x1, y1).clearCofactor();
    }
    static fromPrivateKey(privateKey) {
        return this.BASE.multiplyPrecomputed(normalizePrivKey(privateKey));
    }
    toRawBytes(isCompressed = false) {
        return (0, math_js_1.hexToBytes)(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        this.assertValidity();
        if (isCompressed) {
            const { P } = math_js_1.CURVE;
            let hex;
            if (this.isZero()) {
                hex = POW_2_383 + POW_2_382;
            }
            else {
                const [x, y] = this.toAffine();
                const flag = (y.value * 2n) / P;
                hex = x.value + flag * POW_2_381 + POW_2_383;
            }
            return toPaddedHex(hex, PUBLIC_KEY_LENGTH);
        }
        else {
            if (this.isZero()) {
                return '4'.padEnd(2 * 2 * PUBLIC_KEY_LENGTH, '0');
            }
            else {
                const [x, y] = this.toAffine();
                return toPaddedHex(x.value, PUBLIC_KEY_LENGTH) + toPaddedHex(y.value, PUBLIC_KEY_LENGTH);
            }
        }
    }
    assertValidity() {
        if (this.isZero())
            return this;
        if (!this.isOnCurve())
            throw new Error('Invalid G1 point: not on curve Fp');
        if (!this.isTorsionFree())
            throw new Error('Invalid G1 point: must be of prime-order subgroup');
        return this;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
    millerLoop(P) {
        return (0, math_js_1.millerLoop)(P.pairingPrecomputes(), this.toAffine());
    }
    clearCofactor() {
        const t = this.mulCurveMinusX();
        return t.add(this);
    }
    isOnCurve() {
        const b = new math_js_1.Fp(math_js_1.CURVE.b);
        const { x, y, z } = this;
        const left = y.pow(2n).multiply(z).subtract(x.pow(3n));
        const right = b.multiply(z.pow(3n));
        return left.subtract(right).isZero();
    }
    sigma() {
        const BETA = 0x1a0111ea397fe699ec02408663d4de85aa0d857d89759ad4897d29650fb85f9b409427eb4f49fffd8bfd00000000aaacn;
        const [x, y] = this.toAffine();
        return new PointG1(x.multiply(BETA), y);
    }
    phi() {
        const cubicRootOfUnityModP = 0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffen;
        return new PointG1(this.x.multiply(cubicRootOfUnityModP), this.y, this.z);
    }
    mulCurveX() {
        return this.multiplyUnsafe(math_js_1.CURVE.x).negate();
    }
    mulCurveMinusX() {
        return this.multiplyUnsafe(math_js_1.CURVE.x);
    }
    isTorsionFree() {
        const xP = this.mulCurveX();
        const u2P = xP.mulCurveMinusX();
        return u2P.equals(this.phi());
    }
}
exports.PointG1 = PointG1;
PointG1.BASE = new PointG1(new math_js_1.Fp(math_js_1.CURVE.Gx), new math_js_1.Fp(math_js_1.CURVE.Gy), math_js_1.Fp.ONE);
PointG1.ZERO = new PointG1(math_js_1.Fp.ONE, math_js_1.Fp.ONE, math_js_1.Fp.ZERO);
class PointG2 extends math_js_1.ProjectivePoint {
    constructor(x, y, z = math_js_1.Fp2.ONE) {
        super(x, y, z, math_js_1.Fp2);
        assertType(x, math_js_1.Fp2);
        assertType(y, math_js_1.Fp2);
        assertType(z, math_js_1.Fp2);
    }
    static async hashToCurve(msg, options) {
        msg = ensureBytes(msg);
        const u = await hash_to_field(msg, 2, options);
        const [x0, y0] = (0, math_js_1.map_to_curve_simple_swu_9mod16)(math_js_1.Fp2.fromBigTuple(u[0]));
        const [x1, y1] = (0, math_js_1.map_to_curve_simple_swu_9mod16)(math_js_1.Fp2.fromBigTuple(u[1]));
        const [x2, y2] = new PointG2(x0, y0).add(new PointG2(x1, y1)).toAffine();
        const [x3, y3] = (0, math_js_1.isogenyMapG2)(x2, y2);
        return new PointG2(x3, y3).clearCofactor();
    }
    static async encodeToCurve(msg, options) {
        msg = ensureBytes(msg);
        const u = await hash_to_field(msg, 1, options);
        const [x0, y0] = (0, math_js_1.map_to_curve_simple_swu_9mod16)(math_js_1.Fp2.fromBigTuple(u[0]));
        const [x1, y1] = (0, math_js_1.isogenyMapG2)(x0, y0);
        return new PointG2(x1, y1).clearCofactor();
    }
    static fromSignature(hex) {
        hex = ensureBytes(hex);
        const { P } = math_js_1.CURVE;
        const half = hex.length / 2;
        if (half !== 48 && half !== 96)
            throw new Error('Invalid compressed signature length, must be 96 or 192');
        const z1 = (0, math_js_1.bytesToNumberBE)(hex.slice(0, half));
        const z2 = (0, math_js_1.bytesToNumberBE)(hex.slice(half));
        const bflag1 = (0, math_js_1.mod)(z1, POW_2_383) / POW_2_382;
        if (bflag1 === 1n)
            return this.ZERO;
        const x1 = new math_js_1.Fp(z1 % POW_2_381);
        const x2 = new math_js_1.Fp(z2);
        const x = new math_js_1.Fp2(x2, x1);
        const y2 = x.pow(3n).add(math_js_1.Fp2.fromBigTuple(math_js_1.CURVE.b2));
        let y = y2.sqrt();
        if (!y)
            throw new Error('Failed to find a square root');
        const { re: y0, im: y1 } = y.reim();
        const aflag1 = (z1 % POW_2_382) / POW_2_381;
        const isGreater = y1 > 0n && (y1 * 2n) / P !== aflag1;
        const isZero = y1 === 0n && (y0 * 2n) / P !== aflag1;
        if (isGreater || isZero)
            y = y.multiply(-1n);
        const point = new PointG2(x, y, math_js_1.Fp2.ONE);
        point.assertValidity();
        return point;
    }
    static fromHex(bytes) {
        bytes = ensureBytes(bytes);
        const m_byte = bytes[0] & 0xe0;
        if (m_byte === 0x20 || m_byte === 0x60 || m_byte === 0xe0) {
            throw new Error('Invalid encoding flag: ' + m_byte);
        }
        const bitC = m_byte & 0x80;
        const bitI = m_byte & 0x40;
        const bitS = m_byte & 0x20;
        let point;
        if (bytes.length === 96 && bitC) {
            const { P, b2 } = math_js_1.CURVE;
            const b = math_js_1.Fp2.fromBigTuple(b2);
            bytes[0] = bytes[0] & 0x1f;
            if (bitI) {
                if (bytes.reduce((p, c) => (p !== 0 ? c + 1 : c), 0) > 0) {
                    throw new Error('Invalid compressed G2 point');
                }
                return PointG2.ZERO;
            }
            const x_1 = (0, math_js_1.bytesToNumberBE)(bytes.slice(0, PUBLIC_KEY_LENGTH));
            const x_0 = (0, math_js_1.bytesToNumberBE)(bytes.slice(PUBLIC_KEY_LENGTH));
            const x = new math_js_1.Fp2(new math_js_1.Fp(x_0), new math_js_1.Fp(x_1));
            const right = x.pow(3n).add(b);
            let y = right.sqrt();
            if (!y)
                throw new Error('Invalid compressed G2 point');
            const Y_bit = y.c1.value === 0n ? (y.c0.value * 2n) / P : (y.c1.value * 2n) / P ? 1n : 0n;
            y = bitS > 0 && Y_bit > 0 ? y : y.negate();
            return new PointG2(x, y);
        }
        else if (bytes.length === 192 && !bitC) {
            if ((bytes[0] & (1 << 6)) !== 0) {
                return PointG2.ZERO;
            }
            const x1 = (0, math_js_1.bytesToNumberBE)(bytes.slice(0, PUBLIC_KEY_LENGTH));
            const x0 = (0, math_js_1.bytesToNumberBE)(bytes.slice(PUBLIC_KEY_LENGTH, 2 * PUBLIC_KEY_LENGTH));
            const y1 = (0, math_js_1.bytesToNumberBE)(bytes.slice(2 * PUBLIC_KEY_LENGTH, 3 * PUBLIC_KEY_LENGTH));
            const y0 = (0, math_js_1.bytesToNumberBE)(bytes.slice(3 * PUBLIC_KEY_LENGTH));
            point = new PointG2(math_js_1.Fp2.fromBigTuple([x0, x1]), math_js_1.Fp2.fromBigTuple([y0, y1]));
        }
        else {
            throw new Error('Invalid point G2, expected 96/192 bytes');
        }
        point.assertValidity();
        return point;
    }
    static fromPrivateKey(privateKey) {
        return this.BASE.multiplyPrecomputed(normalizePrivKey(privateKey));
    }
    toSignature() {
        if (this.equals(PointG2.ZERO)) {
            const sum = POW_2_383 + POW_2_382;
            const h = toPaddedHex(sum, PUBLIC_KEY_LENGTH) + toPaddedHex(0n, PUBLIC_KEY_LENGTH);
            return (0, math_js_1.hexToBytes)(h);
        }
        const [{ re: x0, im: x1 }, { re: y0, im: y1 }] = this.toAffine().map((a) => a.reim());
        const tmp = y1 > 0n ? y1 * 2n : y0 * 2n;
        const aflag1 = tmp / math_js_1.CURVE.P;
        const z1 = x1 + aflag1 * POW_2_381 + POW_2_383;
        const z2 = x0;
        return (0, math_js_1.hexToBytes)(toPaddedHex(z1, PUBLIC_KEY_LENGTH) + toPaddedHex(z2, PUBLIC_KEY_LENGTH));
    }
    toRawBytes(isCompressed = false) {
        return (0, math_js_1.hexToBytes)(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        this.assertValidity();
        if (isCompressed) {
            const { P } = math_js_1.CURVE;
            let x_1 = 0n;
            let x_0 = 0n;
            if (this.isZero()) {
                x_1 = POW_2_383 + POW_2_382;
            }
            else {
                const [x, y] = this.toAffine();
                const flag = y.c1.value === 0n ? (y.c0.value * 2n) / P : (y.c1.value * 2n) / P ? 1n : 0n;
                x_1 = x.c1.value + flag * POW_2_381 + POW_2_383;
                x_0 = x.c0.value;
            }
            return toPaddedHex(x_1, PUBLIC_KEY_LENGTH) + toPaddedHex(x_0, PUBLIC_KEY_LENGTH);
        }
        else {
            if (this.equals(PointG2.ZERO)) {
                return '4'.padEnd(2 * 4 * PUBLIC_KEY_LENGTH, '0');
            }
            const [{ re: x0, im: x1 }, { re: y0, im: y1 }] = this.toAffine().map((a) => a.reim());
            return (toPaddedHex(x1, PUBLIC_KEY_LENGTH) +
                toPaddedHex(x0, PUBLIC_KEY_LENGTH) +
                toPaddedHex(y1, PUBLIC_KEY_LENGTH) +
                toPaddedHex(y0, PUBLIC_KEY_LENGTH));
        }
    }
    assertValidity() {
        if (this.isZero())
            return this;
        if (!this.isOnCurve())
            throw new Error('Invalid G2 point: not on curve Fp2');
        if (!this.isTorsionFree())
            throw new Error('Invalid G2 point: must be of prime-order subgroup');
        return this;
    }
    psi() {
        return this.fromAffineTuple((0, math_js_1.psi)(...this.toAffine()));
    }
    psi2() {
        return this.fromAffineTuple((0, math_js_1.psi2)(...this.toAffine()));
    }
    mulCurveX() {
        return this.multiplyUnsafe(math_js_1.CURVE.x).negate();
    }
    clearCofactor() {
        const P = this;
        let t1 = P.mulCurveX();
        let t2 = P.psi();
        let t3 = P.double();
        t3 = t3.psi2();
        t3 = t3.subtract(t2);
        t2 = t1.add(t2);
        t2 = t2.mulCurveX();
        t3 = t3.add(t2);
        t3 = t3.subtract(t1);
        const Q = t3.subtract(P);
        return Q;
    }
    isOnCurve() {
        const b = math_js_1.Fp2.fromBigTuple(math_js_1.CURVE.b2);
        const { x, y, z } = this;
        const left = y.pow(2n).multiply(z).subtract(x.pow(3n));
        const right = b.multiply(z.pow(3n));
        return left.subtract(right).isZero();
    }
    isTorsionFree() {
        const P = this;
        return P.mulCurveX().equals(P.psi());
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this.toString();
    }
    clearPairingPrecomputes() {
        this._PPRECOMPUTES = undefined;
    }
    pairingPrecomputes() {
        if (this._PPRECOMPUTES)
            return this._PPRECOMPUTES;
        this._PPRECOMPUTES = (0, math_js_1.calcPairingPrecomputes)(...this.toAffine());
        return this._PPRECOMPUTES;
    }
}
exports.PointG2 = PointG2;
PointG2.BASE = new PointG2(math_js_1.Fp2.fromBigTuple(math_js_1.CURVE.G2x), math_js_1.Fp2.fromBigTuple(math_js_1.CURVE.G2y), math_js_1.Fp2.ONE);
PointG2.ZERO = new PointG2(math_js_1.Fp2.ONE, math_js_1.Fp2.ONE, math_js_1.Fp2.ZERO);
function pairing(P, Q, withFinalExponent = true) {
    if (P.isZero() || Q.isZero())
        throw new Error('No pairings at point of Infinity');
    P.assertValidity();
    Q.assertValidity();
    const looped = P.millerLoop(Q);
    return withFinalExponent ? looped.finalExponentiate() : looped;
}
exports.pairing = pairing;
function normP1(point) {
    return point instanceof PointG1 ? point : PointG1.fromHex(point);
}
function normP2(point) {
    return point instanceof PointG2 ? point : PointG2.fromSignature(point);
}
async function normP2Hash(point) {
    return point instanceof PointG2 ? point : PointG2.hashToCurve(point);
}
function getPublicKey(privateKey) {
    return PointG1.fromPrivateKey(privateKey).toRawBytes(true);
}
exports.getPublicKey = getPublicKey;
async function sign(message, privateKey) {
    const msgPoint = await normP2Hash(message);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(normalizePrivKey(privateKey));
    if (message instanceof PointG2)
        return sigPoint;
    return sigPoint.toSignature();
}
exports.sign = sign;
async function verify(signature, message, publicKey) {
    const P = normP1(publicKey);
    const Hm = await normP2Hash(message);
    const G = PointG1.BASE;
    const S = normP2(signature);
    const ePHm = pairing(P.negate(), Hm, false);
    const eGS = pairing(G, S, false);
    const exp = eGS.multiply(ePHm).finalExponentiate();
    return exp.equals(math_js_1.Fp12.ONE);
}
exports.verify = verify;
function aggregatePublicKeys(publicKeys) {
    if (!publicKeys.length)
        throw new Error('Expected non-empty array');
    const agg = publicKeys.map(normP1).reduce((sum, p) => sum.add(p), PointG1.ZERO);
    if (publicKeys[0] instanceof PointG1)
        return agg.assertValidity();
    return agg.toRawBytes(true);
}
exports.aggregatePublicKeys = aggregatePublicKeys;
function aggregateSignatures(signatures) {
    if (!signatures.length)
        throw new Error('Expected non-empty array');
    const agg = signatures.map(normP2).reduce((sum, s) => sum.add(s), PointG2.ZERO);
    if (signatures[0] instanceof PointG2)
        return agg.assertValidity();
    return agg.toSignature();
}
exports.aggregateSignatures = aggregateSignatures;
async function verifyBatch(signature, messages, publicKeys) {
    if (!messages.length)
        throw new Error('Expected non-empty messages array');
    if (publicKeys.length !== messages.length)
        throw new Error('Pubkey count should equal msg count');
    const sig = normP2(signature);
    const nMessages = await Promise.all(messages.map(normP2Hash));
    const nPublicKeys = publicKeys.map(normP1);
    try {
        const paired = [];
        for (const message of new Set(nMessages)) {
            const groupPublicKey = nMessages.reduce((groupPublicKey, subMessage, i) => subMessage === message ? groupPublicKey.add(nPublicKeys[i]) : groupPublicKey, PointG1.ZERO);
            paired.push(pairing(groupPublicKey, message, false));
        }
        paired.push(pairing(PointG1.BASE.negate(), sig, false));
        const product = paired.reduce((a, b) => a.multiply(b), math_js_1.Fp12.ONE);
        const exp = product.finalExponentiate();
        return exp.equals(math_js_1.Fp12.ONE);
    }
    catch {
        return false;
    }
}
exports.verifyBatch = verifyBatch;
PointG1.BASE.calcMultiplyPrecomputes(4);
