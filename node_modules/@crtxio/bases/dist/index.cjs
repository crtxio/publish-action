'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const abstract = require('./abstract.cjs');

class IdentityCodec extends abstract.MultibaseCodec {
  constructor(name, prefix) {
    super(name, prefix);
  }
  isValid(str) {
    return str[0] === this.prefix;
  }
  encode(bytes, prefix = true) {
    const str = new TextDecoder().decode(bytes);
    return prefix ? this.prefix + str : str;
  }
  decode(str, prefix = true) {
    if (prefix && this.prefix) {
      if (str[0] != this.prefix)
        throw Error("invalid encoding");
      str = str.slice(1);
    }
    return new TextEncoder().encode(str);
  }
  static from({
    name,
    prefix
  }) {
    return new IdentityCodec(name, prefix);
  }
}
const identity = new IdentityCodec("identity", "\0");
const utf8 = new IdentityCodec("utf8", "");

const HexRegex = /(?<=^(0x)?)[a-f0-9]{1}(?=([a-f0-9]{2})*$)|(?<=^(0x)?[a-f0-9]*)([a-f0-9]{2})/gi;
const IsHex = /^(0x)?[a-f0-9]*$/i;
class HexCodec extends abstract.MultibaseCodec {
  constructor(name, prefix) {
    super(name, prefix);
  }
  isValid(str) {
    return IsHex.test(str);
  }
  encode(bytes, prefix = true) {
    const hex2 = bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
    return prefix ? this.prefix + hex2 : hex2;
  }
  decode(str) {
    if (!this.isValid(str))
      throw Error("invalid encoding");
    const bytes = (str.match(HexRegex) ?? []).map((byte) => parseInt(byte, 16));
    return Uint8Array.from(bytes);
  }
}
const hex = new HexCodec("hex", "0x");

class Bases {
  constructor(bases = {}) {
    this.bases = bases;
    const prefixes = [];
    this.bases = { hex, utf8, identity, ...bases };
    for (const base of Object.values(this.bases)) {
      if (base.prefix)
        prefixes.push(base.prefix);
      this.bases[base.prefix] = base;
    }
    this.detector = new RegExp(`^(${prefixes.sort().reverse().join("|")})`);
  }
  encode(bytes, encoding = "hex", prefix = true) {
    const base = this.bases[encoding];
    if (!base)
      throw Error(`what is ${encoding}!?`);
    return base.encode(bytes, prefix);
  }
  decode(str, encoding) {
    const prefix = !encoding;
    const base = encoding ? this.bases[encoding] : this.detect(str);
    if (!base)
      throw Error(`what is ${encoding}!?`);
    return base.decode(str, prefix);
  }
  ensure(input, encoding) {
    if (input instanceof Uint8Array)
      return input;
    return this.decode(input, encoding);
  }
  detect(str) {
    const [prefix] = this.detector.exec(str) || [];
    const base = this.bases[prefix];
    if (base && base.isValid(str))
      return base;
    return this.bases["utf8"];
  }
  transcode(str, to, from, prefix = true) {
    const bytes = this.decode(str, from);
    return this.encode(bytes, to, prefix);
  }
}

exports.MultibaseCodec = abstract.MultibaseCodec;
exports.Bases = Bases;
