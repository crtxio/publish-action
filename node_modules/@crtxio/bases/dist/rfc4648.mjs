import { MultibaseCodec } from './abstract.mjs';

class RFC4648 extends MultibaseCodec {
  constructor(name, prefix, alphabet, bits) {
    super(name, prefix);
    this._validator = new RegExp(`^${prefix}[${alphabet}]+$`);
    this._alphabet = alphabet;
    this._bits = bits;
  }
  get alphabet() {
    return this._alphabet;
  }
  get bits() {
    return this._bits;
  }
  isValid(str) {
    return this._validator.test(str);
  }
  encode(bytes, prefix = true) {
    const pad = this.alphabet[this.alphabet.length - 1] === "=";
    const mask = (1 << this.bits) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < bytes.length; ++i) {
      buffer = buffer << 8 | bytes[i];
      bits += 8;
      while (bits > this.bits) {
        bits -= this.bits;
        out += this.alphabet[mask & buffer >> bits];
      }
    }
    if (bits) {
      out += this.alphabet[mask & buffer << this.bits - bits];
    }
    if (pad) {
      while (out.length * this.bits & 7) {
        out += "=";
      }
    }
    return prefix ? this.prefix + out : out;
  }
  decode(str, prefix = true) {
    if (prefix) {
      if (!this.isValid(str))
        throw Error("invalid encoding");
      str = str.slice(1);
    }
    const codes = {};
    for (let i = 0; i < this.alphabet.length; ++i) {
      codes[this.alphabet[i]] = i;
    }
    let end = str.length;
    while (str[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * this.bits / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[str[i]];
      if (value === void 0) {
        throw new SyntaxError(`Non-${this.name} character`);
      }
      buffer = buffer << this.bits | value;
      bits += this.bits;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= this.bits || 255 & buffer << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  }
  static from({
    name,
    prefix,
    alphabet,
    bits
  }) {
    return new RFC4648(name, prefix, alphabet, bits);
  }
}

export { RFC4648 };
