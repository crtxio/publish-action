import { CID } from '@crtxio/primitives/cid';
import * as secp256k1 from '@noble/secp256k1';

declare type BytesLike$1 = string | Uint8Array;
declare class Commit {
    protected _bytes: Uint8Array;
    protected _iss: Uint8Array;
    protected _ptr: Uint8Array;
    protected _rev: number;
    protected _sig: Uint8Array;
    protected _sub: string;
    constructor(bytes: BytesLike$1);
    get iss(): Uint8Array;
    get ptr(): CID;
    get rev(): number;
    get sig(): Uint8Array;
    get sub(): string;
    get addr(): string;
    get id(): string;
    get bytes(): Uint8Array;
    get encoded(): string;
    get json(): {
        addr: string;
        iss: string;
        ptr: string;
        rev: number;
        sig: string;
        sub: string;
        valid: boolean;
    };
    get sigmsg(): string;
    get sighash(): Uint8Array;
    get valid(): boolean;
    sign(sig: BytesLike$1, sub?: string): void;
    static from(bytes: BytesLike$1): Commit;
    static create({ iss, ptr, rev }: {
        iss: BytesLike$1;
        ptr: string;
        rev: number;
    }, topic?: string): Commit;
    static sign({ ptr, rev }: {
        ptr: string;
        rev?: number;
    }, signer: BytesLike$1, topic?: string): Promise<Commit>;
}

declare type Bytes = Uint8Array;
declare type BytesLike = Bytes | string;
declare type Point = secp256k1.Point;
declare type PublicKey = Point | BytesLike;
declare type PrivateKey = BytesLike;
interface PublicKeyInfo {
    address: string;
    publicKey: Uint8Array;
    channel: string;
    label: string;
}
declare function detectCurve(_: PublicKey | PrivateKey): any;
declare function toPoint(pointy: PublicKey): Point;
declare function fromPoint(point: Point): Uint8Array;
declare function normalizePublicKey(bytes: PublicKey, compressed?: boolean): Uint8Array;
declare function toAddr(pk: PublicKey): string;
declare function toPublicKey(key: PrivateKey): Bytes;
declare function sign(message: BytesLike, privateKey: PrivateKey): Promise<Bytes>;
declare function sighash(msg: string): Bytes;
declare function recoverPublicKey(sig: BytesLike, msg: BytesLike): Uint8Array;
declare function derivePublicKey(publicKey: PublicKey, label: string, channel?: BytesLike): PublicKeyInfo;
declare function derivePublicKeys(publicKey: PublicKey, topic: string | string[], channel?: BytesLike): PublicKeyInfo[];
declare function nh(fqn: string, root?: Bytes): Bytes;

export { Commit, derivePublicKey, derivePublicKeys, detectCurve, fromPoint, nh, normalizePublicKey, recoverPublicKey, sighash, sign, toAddr, toPoint, toPublicKey };
