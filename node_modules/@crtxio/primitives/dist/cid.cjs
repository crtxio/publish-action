'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const varint = require('@crtxio/utils/varint');
const bytes = require('./bytes.cjs');
const eip712 = require('eip-712');
const hashers = require('@crtxio/hashers');
const sha3 = require('@crtxio/hashers/sha3');
require('@crtxio/utils');
require('@crtxio/utils/calc');
require('@crtxio/bases');
require('@crtxio/bases/base32');
require('@crtxio/bases/base58');
require('@crtxio/bases/base64');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      n[k] = e[k];
    }
  }
  n["default"] = e;
  return n;
}

const sha3__namespace = /*#__PURE__*/_interopNamespace(sha3);

const CommonHashers = new hashers.Hashers({ ...sha3__namespace });
class Hash extends bytes.Bytes {
  constructor(bytes, code) {
    super(bytes);
    this.code = code;
  }
  get raw() {
    return bytes.Bytes.from([
      ...varint.varint.encode(this.code),
      ...varint.varint.encode(this.length),
      ...this
    ]);
  }
  to(encoding = "hex", prefix = true) {
    return this.raw.toString(encoding, prefix);
  }
  static is(hash) {
    try {
      hash = this.from(hash);
      return hash instanceof Hash;
    } catch {
      return false;
    }
  }
  static from(hash) {
    if (hash instanceof Hash)
      return hash;
    const bytes$1 = bytes.Bytes.from(hash);
    const code = varint.varint.take(bytes$1);
    const len = varint.varint.take(bytes$1, code[1]);
    const digest = bytes$1.slice(len[1]);
    return new Hash(digest, code[0]);
  }
  static async create(data, hasher = "identity") {
    if (eip712.validateTypedData(data))
      return new Hash(eip712.getMessage(data, true), 27);
    const bytes$1 = bytes.Bytes.ensure(data);
    const { digest, code } = await CommonHashers.encode(bytes$1, hasher);
    return new Hash(digest, code);
  }
}

const Codecs = {
  identity: 0,
  "bls12_381-g1-pub": 234,
  "bls12_381-g2-pub": 235,
  "secp256k1-pub": 231,
  "keccak-256": 27,
  "sha2-256": 18,
  "eth-block": 144,
  "dag-cbor": 113,
  "dag-pb": 112,
  cbor: 81
};
const CodecNames = [];
for (const codec of Object.keys(Codecs)) {
  CodecNames[Codecs[codec]] = codec;
}
const isV0 = RegExp("^Qm[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{44}$");
class CID extends bytes.Bytes {
  constructor(hash, code, version = 1) {
    const bytes$1 = version ? bytes.Bytes.from([version, ...varint.varint.encode(code), ...hash.raw]) : hash.raw;
    super(bytes$1);
    this.hash = hash;
    this.code = code;
    this.version = version;
  }
  get raw() {
    return bytes.Bytes.from(this);
  }
  get v0() {
    return this.version ? new CID(this.hash, this.code, 0) : this;
  }
  get v1() {
    return this.version ? this : new CID(this.hash, this.code, 1);
  }
  get alg() {
    return CodecNames[this.hash.code] || "0x" + this.hash.code.toString(16);
  }
  get codec() {
    return CodecNames[this.code];
  }
  get humanize() {
    const version = this.version ? "cidv1" : "cidv0";
    return [
      version,
      this.codec,
      this.alg,
      this.hash.length,
      this.hash.to("hex", false)
    ].join(" - ");
  }
  to(encoding = "base32") {
    if (this.version == 0)
      return this.hash.to("base58btc", false);
    return super.toString(encoding, true);
  }
  static is(cid) {
    try {
      cid = this.from(cid);
      return cid instanceof CID;
    } catch {
      return false;
    }
  }
  static isV0(cid) {
    if (typeof cid == "string")
      return isV0.test(cid);
    const bytes$1 = bytes.Bytes.ensure(cid);
    return bytes$1.length == 34 && bytes$1[0] == 18 && bytes$1[1] == 32;
  }
  static isV1(cid) {
    const bytes$1 = bytes.Bytes.ensure(cid);
    return bytes$1[0] == 1;
  }
  static from(cid) {
    if (cid instanceof CID)
      return cid;
    if (CID.isV0(cid)) {
      return new CID(Hash.from(bytes.Bytes.ensure(cid, "base58btc")), 112, 0);
    }
    const bytes$1 = bytes.Bytes.ensure(cid);
    if (!CID.isV1(cid))
      throw Error("invalid CID");
    const [codec, offset] = varint.varint.take(bytes$1, 1);
    const hash = Hash.from(bytes$1.slice(offset));
    return new CID(hash, codec, 1);
  }
  static create(hash, codec, version = 1) {
    if (typeof codec == "string")
      codec = Codecs[codec];
    return new CID(Hash.from(hash), codec, version);
  }
}

exports.CID = CID;
