import * as cbor from 'cborg';
import { CID } from '@crtxio/primitives/cid';
import { hex } from '@crtxio/utils/hex';
import * as secp256k1 from '@noble/secp256k1';
import 'crypto';

const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianess.
// So, just to be sure not to corrupt anything.
if (!isLE)
    throw new Error('Non little-endian hardware is not supported');
Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
// Currently avoid insertion of polyfills with packers (browserify/webpack/etc)
// But setTimeout is pretty slow, maybe worth to investigate howto do minimal polyfill here
(() => {
    const nodeRequire = typeof module !== 'undefined' &&
        typeof module.require === 'function' &&
        module.require.bind(module);
    try {
        if (nodeRequire) {
            const { setImmediate } = nodeRequire('timers');
            return () => new Promise((resolve) => setImmediate(resolve));
        }
    }
    catch (e) { }
    return () => new Promise((resolve) => setTimeout(resolve, 0));
})();
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
function assertNumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}

// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
class Keccak extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        assertNumber(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        if (this.destroyed)
            throw new Error('instance is destroyed');
        if (this.finished)
            throw new Error('digest() was already called');
        const { blockLen, state } = this;
        data = toBytes(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        if (this.destroyed)
            throw new Error('instance is destroyed');
        if (!(out instanceof Uint8Array))
            throw new Error('Keccak: invalid output buffer');
        this.finish();
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= this.blockLen)
                this.keccak();
            const take = Math.min(this.blockLen - this.posOut, len - pos);
            out.set(this.state.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        assertNumber(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        if (out.length < this.outputLen)
            throw new Error('Keccak: invalid output buffer');
        if (this.finished)
            throw new Error('digest() was already called');
        this.finish();
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
const gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
gen(0x06, 136, 256 / 8);
gen(0x06, 104, 384 / 8);
gen(0x06, 72, 512 / 8);
gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
const keccak_256 = gen(0x01, 136, 256 / 8);
gen(0x01, 104, 384 / 8);
gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen !== undefined ? opts.dkLen : outputLen, true));
genShake(0x1f, 168, 128 / 8);
genShake(0x1f, 136, 256 / 8);

const { concatBytes } = secp256k1.utils;
const ROOT = new Uint8Array(32);
const Curves = {
  231: {
    code: 231,
    name: "secp256k1",
    Point: secp256k1.Point,
    toPoint(bytes) {
      if (bytes instanceof secp256k1.Point) {
        return bytes;
      }
      bytes = hex.toBytes(bytes);
      return secp256k1.Point.fromHex(bytes);
    },
    fromPoint(point, compressed = true) {
      return point.toRawBytes(compressed);
    },
    toPublicKey(privateKey) {
      privateKey = hex.toBytes(privateKey);
      return secp256k1.getPublicKey(privateKey);
    },
    async sign(message, privateKey) {
      message = hex.toBytes(message);
      privateKey = hex.toBytes(privateKey);
      const [sig, v] = await secp256k1.sign(message, privateKey, { recovered: true, der: false });
      return concatBytes(sig, new Uint8Array([v]));
    }
  }
};
function detectCurve(_) {
  return Curves[231];
}
function toPoint(pointy) {
  return detectCurve().toPoint(pointy);
}
function fromPoint(point) {
  return detectCurve().fromPoint(point);
}
function normalizePublicKey(bytes, compressed = true) {
  const curve = detectCurve();
  return curve.fromPoint(curve.toPoint(bytes), compressed);
}
function toAddr(pk) {
  pk = normalizePublicKey(pk, false);
  return hex.fromBytes(keccak_256(pk.slice(1)).slice(12));
}
function toPublicKey(key) {
  const curve = detectCurve();
  return curve.toPublicKey(key);
}
function sign(message, privateKey) {
  const curve = detectCurve();
  return curve.sign(message, privateKey);
}
function sighash(msg) {
  return keccak_256(`Ethereum Signed Message:
${msg.length}${msg}`);
}
function recoverPublicKey(sig, msg) {
  sig = hex.toBytes(sig);
  msg = hex.toBytes(msg);
  let v = sig[64];
  v = 1 - (v < 27 ? v + 27 : v) % 2;
  sig = sig.slice(0, 64);
  return secp256k1.recoverPublicKey(msg, sig, v);
}
function derivePublicKey(publicKey, label, channel = new Uint8Array(32)) {
  channel = hex.fromBytes(keccak_256(concatBytes(hex.toBytes(channel), keccak_256(label))));
  publicKey = fromPoint(toPoint(publicKey).multiply(BigInt(channel)));
  return {
    address: toAddr(publicKey),
    publicKey,
    channel,
    label
  };
}
function derivePublicKeys(publicKey, topic, channel = new Uint8Array(32)) {
  if (typeof topic === "string")
    topic = topic.split(".").reverse();
  if (!Array.isArray(topic))
    throw Error("invalid topic");
  if (!topic.length)
    return [];
  const [label, ...labels] = topic;
  const PublicKey = derivePublicKey(publicKey, label, channel);
  return [...derivePublicKeys(PublicKey.publicKey, labels, PublicKey.channel), PublicKey];
}
function nh(fqn, root = ROOT) {
  return fqn.split(".").reverse().reduce((parent, label) => {
    return keccak_256(concatBytes(parent, keccak_256(label)));
  }, root);
}

class Commit {
  constructor(bytes) {
    bytes = hex.toBytes(bytes);
    const [iss, ptr, rev, sig, sub] = cbor.decode(bytes);
    this._bytes = bytes;
    this._iss = iss;
    this._ptr = ptr;
    this._rev = rev;
    this._sig = sig;
    this._sub = sub;
  }
  get iss() {
    return this._iss;
  }
  get ptr() {
    return CID.from(this._ptr);
  }
  get rev() {
    return this._rev;
  }
  get sig() {
    return this._sig;
  }
  get sub() {
    return this._sub;
  }
  get addr() {
    return toAddr(this._iss);
  }
  get id() {
    return `${this.addr}:${this.rev.toString().padStart(20, "0")}`;
  }
  get bytes() {
    const commit = [this._iss, this._ptr, this._rev];
    if (this._sig)
      commit.push(this._sig);
    if (this._sub)
      commit.push(this._sub);
    return cbor.encode(commit);
  }
  get encoded() {
    return hex.fromBytes(this.bytes);
  }
  get json() {
    return {
      addr: this.addr,
      iss: hex.fromBytes(this.iss),
      ptr: this.ptr.to("base32"),
      rev: this.rev,
      sig: hex.fromBytes(this.sig),
      sub: this.sub,
      valid: this.valid
    };
  }
  get sigmsg() {
    return [
      "COMMIT crtx",
      `Issuer: ${this.addr}`,
      `Pointer: ${this.ptr.to("base32")}`,
      `Revision: ${this.rev}`
    ].join("\n");
  }
  get sighash() {
    return sighash(this.sigmsg);
  }
  get valid() {
    let signer = recoverPublicKey(this.sig, this.sighash);
    if (this.sub) {
      signer = derivePublicKeys(signer, this.sub)[0].publicKey;
    }
    const addr = toAddr(signer);
    return addr === this.addr;
  }
  sign(sig, sub = "") {
    this._sig = hex.toBytes(sig);
    this._sub = sub;
  }
  static from(bytes) {
    return new Commit(bytes);
  }
  static create({ iss, ptr, rev = Date.now() }, topic = "") {
    if (topic)
      iss = derivePublicKeys(iss, topic)[0].publicKey;
    iss = normalizePublicKey(iss);
    const cid = CID.from(ptr);
    const bytes = cbor.encode([iss, cid.bytes, rev]);
    return new Commit(bytes);
  }
  static async sign({ ptr, rev = Date.now() }, signer, topic = "") {
    const iss = toPublicKey(signer);
    const commit = Commit.create({ iss, ptr, rev }, topic);
    const sig = await sign(commit.sighash, signer);
    commit.sign(sig, topic);
    return commit;
  }
}

export { Commit, derivePublicKey, derivePublicKeys, detectCurve, fromPoint, nh, normalizePublicKey, recoverPublicKey, sighash, sign, toAddr, toPoint, toPublicKey };
